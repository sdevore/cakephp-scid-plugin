<?php

namespace Scid\Model\Behavior;

use App\Model\Entity\Payment;
use App\Model\Table\PaymentsTable;
use Cake\Log\Log;
use Cake\ORM\Locator\TableLocator;
use Cake\ORM\TableRegistry;
use Money\Number;
use Scid\Model\Entity\CustomerProfile;
use Scid\Model\Entity\MoneyEntityTrait;
use ArrayObject;
use Cake\Core\Configure;
use Cake\Datasource\EntityInterface;
use Cake\Event\Event;
use Cake\ORM\Behavior;
use Cake\ORM\Table;
use Money\Currencies\ISOCurrencies;
use Money\Currency;
use Money\Formatter\DecimalMoneyFormatter;
use Money\Money;
use Money\Parser\IntlMoneyParser;
use net\authorize\api\contract\v1 as AnetAPI;
use net\authorize\api\controller as AnetController;
use PhpParser\Node\Expr\Empty_;
use Scid\Model\Entity\PaymentProfile;
use Scid\Utility\ScidPaymentsInterface;
use Scid\Utility\ScidPaymentsTrait;
use Tools\Model\Entity\Entity;
use Tools\Utility\Text;

/**
 * Payment behavior
 */
class PaymentBehavior extends Behavior implements ScidPaymentsInterface
{

    use MoneyEntityTrait;
    use ScidPaymentsTrait;

    /**
     * Default configuration.
     *
     * @var array
     */


    public function initialize(array $config) {
        parent::initialize($config); // TODO: Change the autogenerated stub
        $this->_initialize($config);


    }

    /**
     * @param Event           $event
     * @param EntityInterface $payment
     * @param ArrayObject     $options
     * @return void|boolean
     */
    public function beforeSave(Event $event, EntityInterface $payment, ArrayObject $options) {
        if (!empty($options[self::TRANSACTION_TRANSACTION_KEY_KEY])) {
            $this->_options['transaction_key'] = $options[self::TRANSACTION_TRANSACTION_KEY_KEY];
        }
        if (!empty($options[self::TRANSACTION_ID_PREFIX_KEY])) {
            $this->_options[self::TRANSACTION_ID_PREFIX_KEY] = $options[self::TRANSACTION_ID_PREFIX_KEY];
        }
        if (!empty($options[self::TRANSACTION_TYPE_KEY])) {
            switch ($options[self::TRANSACTION_TYPE_KEY]) {
                case self::TRANSACTION_TYPE_AUTHORIZE:
                    if (!$this->authorize($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_CAPTURE:
                    if (!$this->capture($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_AUTH_CAPTURE:
                    if (!$this->charge($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_VOID:
                    if (!$this->void($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_REFUND:
                    $payment->setError('type', [__('Refund not supported at this time')]);
                    $event->stopPropagation();
                    return;
                    break;
            }
        }
    }


    /**
     * @param Payment|EntityInterface $payment
     * @return Payment|boolean
     */
    public
    function authorize($payment) {
        $transactionType = self::TRANSACTION_TYPE_AUTHORIZE;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $authPayment = $this->__getAuthPayment($payment);
        $order = $this->__getOrder($payment);

        $customerData = $this->__getCustomerData($payment);
        $customerAddress = $this->__getCustomerAddress($payment);


        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);
        $amount = $this->cleanMoney($payment->amountPaid);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        $this->__setPaymentOrProfile($payment, $transactionRequestType);
        if(empty($payment->payment_profile_id)) {
            $transactionRequestType->setCustomer($customerData);
            $transactionRequestType->setBillTo($customerAddress);
        }
        $transactionRequestType->addToTransactionSettings($this->__duplicateWindowSetting());
        $transactionRequestType->addToTransactionSettings($this->__emailCustomerSetting(FALSE));
        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);

        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $transactionResponse */
                    $transactionResponse = $response->getTransactionResponse();

                    if ($transactionResponse != NULL && $transactionResponse->getMessages() != NULL) {
                        $payment->transactionNumber = $transactionResponse->getTransId();
                        $payment->authorizationNumber = $transactionResponse->getAuthCode();
                        $payment->scid_state = self::STATE_APPROVED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $transactionResponse->getTransId();
                        $result['response_code'] = $transactionResponse->getResponseCode();
                        $result['code'] = $transactionResponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $transactionResponse->getAuthCode();
                        $result['description'] = $transactionResponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($transactionResponse->getErrors() != NULL) {
                            $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();
                            $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $payment->setError('credit_card_number', [__('{0}: {1}',
                                                                         [$errorCode,
                                                                          $errorText])]);
                            $this->__setErrorFromTransactionResponse($payment, $transactionResponse );
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $transactionResponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($transactionResponse != NULL && $transactionResponse->getErrors() != NULL) {
                        $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();

                        $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                        $this->__setErrorFromTransactionResponse($payment, $transactionResponse );
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No response received');
                $payment->setError('credit_card_number', [__('No reponse received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }
        return $payment;

    }


    /**
     * @param EntityInterface|Payment $payment
     * @param array                   $options
     * @return Payment|boolean
     */
    public
    function capture($payment, $options = []) {
        $transactionType = self::TRANSACTION_TYPE_CAPTURE;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $authPayment = $this->__getAuthPayment($payment);
        $order = $this->__getOrder($payment);


        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);
        $amount = $this->cleanMoney($payment->amountPaid);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        if (!empty($payment->transactionNumber)) {
            $transactionRequestType->setRefTransId($payment->transactionNumber);
        } else {
            $payment->setError('transactionNumber', [__('Transaction for capture is not set')]);
            $payment->scid_state = self::STATE_FAILED;
        }
        $customerData = $this->__getCustomerData($payment);
        $transactionRequestType->setCustomer($customerData);
        $transactionRequestType->addToTransactionSettings($this->__duplicateWindowSetting());
        $transactionRequestType->addToTransactionSettings($this->__emailCustomerSetting(TRUE));

        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $transactionResponse */
                    $transactionResponse = $response->getTransactionResponse();

                    if ($transactionResponse != NULL && $transactionResponse->getMessages() != NULL) {
                        $payment->transactionNumber = $transactionResponse->getTransId();
                        $payment->authorizationNumber = $transactionResponse->getAuthCode();
                        $payment->scid_state = self::STATE_CAPTURED;
                        $payment->status = self::STATE_CAPTURED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $transactionResponse->getTransId();
                        $result['response_code'] = $transactionResponse->getResponseCode();
                        $result['code'] = $transactionResponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $transactionResponse->getAuthCode();
                        $result['description'] = $transactionResponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($transactionResponse->getErrors() != NULL) {
                            $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();
                            $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $this->__setError($payment, $errorCode, $errorText);
                            $this->__setErrorFromTransactionResponse($payment, $transactionResponse );
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $transactionResponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($transactionResponse != NULL && $transactionResponse->getErrors() != NULL) {
                        $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();

                        $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No reponse received');
                $payment->setError('credit_card_number', [__('No reponse received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }

        return $payment;
    }

    /**
     * @param EntityInterface|Payment $payment
     *
     * @return Payment|boolean
     */
    public
    function charge($payment) {
        $transactionType = self::TRANSACTION_TYPE_AUTH_CAPTURE;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $order = $this->__getOrder($payment);

        $customerData = $this->__getCustomerData($payment);
        $customerAddress = $this->__getCustomerAddress($payment);

        // Add values for transaction settings
        $duplicateWindowSetting = $this->__duplicateWindowSetting();

        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);
        $amount = $this->cleanMoney($payment->amountPaid);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        $this->__setPaymentOrProfile($payment, $transactionRequestType);
        if(empty($payment->payment_profile_id)) {
            $transactionRequestType->setCustomer($customerData);
            $transactionRequestType->setBillTo($customerAddress);
        }

        $transactionRequestType->addToTransactionSettings($duplicateWindowSetting);

        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $transactionResponse */
                    $transactionResponse = $response->getTransactionResponse();

                    if ($transactionResponse != NULL && $transactionResponse->getMessages() != NULL) {
                        $payment->transactionNumber = $transactionResponse->getTransId();
                        $payment->authorizationNumber = $transactionResponse->getAuthCode();
                        $payment->scid_state = self::STATE_CAPTURED;
                        $payment->status = self::STATE_APPROVED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $transactionResponse->getTransId();
                        $result['response_code'] = $transactionResponse->getResponseCode();
                        $result['code'] = $transactionResponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $transactionResponse->getAuthCode();
                        $result['description'] = $transactionResponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($transactionResponse->getErrors() != NULL) {
                            $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();
                            $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $this->__setError($payment, $errorCode, $errorText, $transactionResponse);
                            $this->__setErrorFromTransactionResponse($payment, $transactionResponse );
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $transactionResponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($transactionResponse != NULL && $transactionResponse->getErrors() != NULL) {
                        $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();

                        $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText, $transactionResponse);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText, $transactionResponse);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No reponse received');
                $payment->setError('credit_card_number', [__('No reponse received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }
        return $payment;
    }

    /**
     * @param Payment|EntityInterface $payment
     *
     * @return bool
     */
    public
    function void($payment) {
        $transactionType = self::TRANSACTION_TYPE_VOID;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        if ($payment->scid_state != self::STATE_APPROVED) {
            $payment->setError('state', [__('Only payments that are approved can be voided')]);
        }

        // Add values for transaction settings
        $duplicateWindowSetting = $this->__duplicateWindowSetting();

        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);

        $transactionRequestType->addToTransactionSettings($duplicateWindowSetting);
        if (!empty($payment->transactionNumber)) {
            $transactionRequestType->setRefTransId($payment->transactionNumber);
        } else {
            $payment->setError('transactionNumber', [__('Transaction for capture is not set')]);
            $payment->scid_state = self::STATE_FAILED;
        }
        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);

        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $transactionResponse */
                    $transactionResponse = $response->getTransactionResponse();

                    if ($transactionResponse != NULL && $transactionResponse->getMessages() != NULL) {
                        $payment->transactionNumber = $transactionResponse->getTransId();
                        $payment->authorizationNumber = $transactionResponse->getAuthCode();
                        $payment->scid_state = self::STATE_VOIDED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $transactionResponse->getTransId();
                        $result['response_code'] = $transactionResponse->getResponseCode();
                        $result['code'] = $transactionResponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $transactionResponse->getAuthCode();
                        $result['description'] = $transactionResponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($transactionResponse->getErrors() != NULL) {
                            $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();
                            $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $this->__setError($payment, $errorCode, $errorText);
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $transactionResponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($transactionResponse != NULL && $transactionResponse->getErrors() != NULL) {
                        $errorCode = $transactionResponse->getErrors()[0]->getErrorCode();

                        $errorText = $transactionResponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No reponse received');
                $payment->setError('credit_card_number', [__('No response received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }
        return $payment;
    }


    /**
     * @param \App\Model\Entity\Payment      $payment
     * @param array                          $data
     * @param \App\Model\Entity\Member|array $member
     *
     * @return array
     */
    public
    function charge2($data, $member) {
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $this->__getReferenceId();

        // create the credit card
        $opaqueData = new AnetAPI\OpaqueDataType();
        $opaqueData->setDataDescriptor($data['dataDescriptor']);
        $opaqueData->setDataValue($data['dataValue']);

        $paymentOne = new AnetAPI\PaymentType();
        $paymentOne->setOpaqueData($opaqueData);

        $order = new AnetAPI\OrderType();
        if (!empty($data['invoice_number'])) {
            $order->setInvoiceNumber($data['invoice_number']);
        }
        if (!empty($data['payment_description'])) {
            $order->setDescription($data['payment_description']);
        } else {
            $order->setDescription(__('CFSD 16 Community Schools Payment'));
        }
        // Set the customer's identifying information
        $customerData = new AnetAPI\CustomerDataType();
        $customerData->setType("individual");
        if ($member instanceof Entity) {
            $customerData->setId($member->id);
            $customerData->setEmail($member->email);
        } else if (is_array($member) && !empty($member['id'])) {
            $customerData->setId($member['id']);
            $customerData->setEmail($member['email']);

        }


        if (!empty($data['items'])) {
            $items = [];
            foreach ($data['items'] as $index => $item) {
                if ($index < 25) {
                    $lineItem = new AnetAPI\LineItemType();
                    if (!empty($item['description'])) {
                        $lineItem->setDescription(Text::truncate($item['description'], 200));
                    }
                    $lineItem->setItemId($item['id']);
                    $lineItem->setName(Text::truncate($item['name'], 25));
                    $unitPrice = $this->cleanMoney($item['fee']);
                    $lineItem->setQuantity(1);
                    $lineItem->setUnitPrice($unitPrice);
                    $items[] = $lineItem;
                } else {

                    break;
                }
            }

        }
        $duplicateWindowSetting = $this->__duplicateWindowSetting();

        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();
        $transactionRequestType->setTransactionType(self::TRANSACTION_TYPE_AUTHORIZE);
        $amount = $this->cleanMoney($data['amountPaid']);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        $transactionRequestType->setPayment($paymentOne);
        $transactionRequestType->setCustomer($customerData);
        $transactionRequestType->addToTransactionSettings($duplicateWindowSetting);
//            if (!empty($items)) {
//                $transactionRequestType->setLineItems($items);
//            }

        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $request->setRefId($this->__getReferenceId());
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if ($this->_sandbox) {
            $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
        } else {
            $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
        }
        $result = [];
        if ($response != NULL) {
            $result['response'] = $response;
            // Check to see if the API request was successfully received and acted upon
            if ($response->getMessages()->getResultCode() == "Ok") {
                // Since the API request was successful, look for a transaction response
                // and parse it to display the results of authorizing the card
                $transactionResponse = $response->getTransactionResponse();

                if ($transactionResponse != NULL && $transactionResponse->getMessages() != NULL) {
                    $result['failed'] = FALSE;
                    $result['transaction_id'] = $transactionResponse->getTransId();
                    $result['response_code'] = $transactionResponse->getResponseCode();
                    $result['code'] = $transactionResponse->getMessages()[0]->getCode();
                    $result['auth_code'] = $transactionResponse->getAuthCode();
                    $result['description'] = $transactionResponse->getMessages()[0]->getDescription();
                } else {
                    $result['failed'] = TRUE;
                    if ($transactionResponse->getErrors() != NULL) {
                        $result['error_code'] = $transactionResponse->getErrors()[0]->getErrorCode();
                        $result['error_message'] = $transactionResponse->getErrors()[0]->getErrorText();
                    }
                }
                // Or, print errors if the API request wasn't successful
            } else {
                $result['failed'] = TRUE;
                $transactionResponse = $response->getTransactionResponse();

                if ($transactionResponse != NULL && $transactionResponse->getErrors() != NULL) {
                    $result['error_code'] = $transactionResponse->getErrors()[0]->getErrorCode();
                    $result['error_message'] = $transactionResponse->getErrors()[0]->getErrorText();
                } else {
                    $result['error_code'] = $response->getMessages()->getMessage()[0]->getCode();
                    $result['error_message'] = $response->getMessages()->getMessage()[0]->getText();
                }
            }
        } else {
            $result['error_message'] = __('No response received');
        }
        return $result;
    }


    /**
     * @return string
     */
    protected
    function __getReferenceId() {
        return 'ref' . time();
    }

    /**
     * @return AnetAPI\SettingType
     */
    protected
    function __duplicateWindowSetting(): AnetAPI\SettingType {
// Add values for transaction settings
        $duplicateWindowSetting = new AnetAPI\SettingType();
        $duplicateWindowSetting->setSettingName("duplicateWindow");
        $duplicateWindowSetting->setSettingValue("60");
        return $duplicateWindowSetting;
    }

    protected
    function __emailCustomerSetting($value = FALSE): AnetAPI\SettingType {
        $setting = new AnetAPI\SettingType();
        $setting->setSettingName("emailCustomer");
        $setting->setSettingValue($value);
        return $setting;
    }

    /**
     * @param $payment
     *
     * @return AnetAPI\CustomerDataType
     */
    protected
    function __getCustomerData($payment): AnetAPI\CustomerDataType {
        $customerData = new AnetAPI\CustomerDataType();
        $customerData->setType("individual");
        if (!empty($payment->email)) {
            $customerData->setEmail($payment->email);
        } else if (!empty($payment->member->email)) {
            $customerData->setEmail($payment->member->email);
        } else {
            $payment->setError('email', [__('no email was set')]);
        }
        if (!empty($payment->member_id)) {
            $customerData->setId($payment->member_id);
        }
        return $customerData;
    }

    /**
     * @param $payment
     *
     * @return AnetAPI\CustomerAddressType
     */
    protected
    function __getCustomerAddress($payment): AnetAPI\CustomerAddressType {
        $customerAddress = new AnetAPI\CustomerAddressType();
        $customerAddress->setFirstName($payment->first);
        $customerAddress->setLastName($payment->last);
        if (!empty($payment->zip)) {
            $customerAddress->setZip($payment->zip);
        }
        if (!empty($payment->address)) {
            $customerAddress->setAddress($payment->address);
        }
        if (!empty($payment->city)) {
            $customerAddress->setCity($payment->city);
        }
        if (!empty($payment->state)) {
            $customerAddress->setState($payment->state);
        }

        return $customerAddress;
    }

    /**
     * @param $payment
     *
     * @return array
     */
    protected
    function __getPaymentItems($payment): array {
        $items = [];
        if (!empty($payment->items)) {
            foreach ($payment->items as $index => $item) {
                if ($index < 25) {
                    $lineItem = new AnetAPI\LineItemType();
                    if (!empty($item['description'])) {
                        $lineItem->setDescription(Text::truncate($item['description'], 200));
                    }
                    $lineItem->setItemId($item['id']);
                    $lineItem->setName(Text::truncate($item['name'], 25));
                    $unitPrice = $this->cleanMoney($item['fee']);
                    $lineItem->setQuantity(1);
                    $lineItem->setUnitPrice($unitPrice);
                    $items[] = $lineItem;
                } else {
                    $lineItem = new AnetAPI\LineItemType();
                    $lineItem->setItemId(0);
                    $lineItem->setName(__('Limit of items.'));
                    $unitPrice = $this->cleanMoney(0);
                    $lineItem->setQuantity(1);
                    $lineItem->setUnitPrice($unitPrice);
                    $items[] = $lineItem;
                    break;
                }
            }

        }
        return $items;
    }


    /**
     * @param $payment
     *
     * @return AnetAPI\PaymentType
     */
    protected function __getAuthPayment($payment): AnetAPI\PaymentType {
        $paymentOne = new AnetAPI\PaymentType();
        // create the credit card
        $validatePayment = FALSE;

        if ($payment->has('dataDescriptor') && $payment->has('dataValue')) {
            // use nonce / opaqueData
            $opaqueData = new AnetAPI\OpaqueDataType();
            $opaqueData->setDataDescriptor($payment->dataDescriptor);
            $opaqueData->setDataValue($payment->dataValue);
            $paymentOne->setOpaqueData($opaqueData);
            $validatePayment = TRUE;
        } else {
            $card = new AnetAPI\CreditCardType();
            if (!empty($payment->credit_card_number)) {
                $number = preg_replace('/\D+/', '', $payment->credit_card_number);
                $card->setCardNumber($number);
                $payment->number = substr($number, -4);
            } else {
                $payment->setError('credit_card_number', [__('credit card number is required')]);
            }
            if (!empty($payment->card_code)) {
                $card->setCardCode($payment->card_code);
            } else {
                $payment->setError('card_code', [__('credit card verification number is required')]);
            }
            if (!empty($payment->expiration_date)) {
                $month = $payment->expiration_date->month;
                $year = $payment->expiration_date->year;
                //Log::debug( $year, 'payment_debug');
                //Log::debug( $month, 'payment_debug');
                $card->setExpirationDate($payment->expiration_date->format('Y-m'));
            } else {
                $payment->setError('expiration_date', [__('no valid expiration date was set')]);
            }
            $paymentOne->setCreditCard($card);
        }
        return $paymentOne;
    }


    /**
     * @param $payment
     *
     * @return AnetAPI\OrderType
     */
    protected
    function __getOrder($payment): AnetAPI\OrderType {
        $order = new AnetAPI\OrderType();
        if (!empty($payment->registrationID)) {
            $invoiceNumber = $payment->registrationID;
            if (!empty($this->_options[self::TRANSACTION_ID_PREFIX_KEY])) {
                $invoiceNumber = $this->_options[self::TRANSACTION_ID_PREFIX_KEY] . '-' . $invoiceNumber;
            }
            $order->setInvoiceNumber($invoiceNumber);
        }
        if (!empty($payment->note)) {
            $order->setDescription(Text::truncate($payment->note, 230));
        } else {
            $order->setDescription(__('CFSD 16 Community Schools Payment'));
        }
        return $order;
    }

    public
    function paymentStatuses() {
        return [
            'Pending'  => 'Pending',
            'Approved' => 'Approved',
            'Failed'   => 'Failed',
            'Captured' => 'Captured',
            'Settled'  => 'Settled',
            'Voided'   => 'Refunded',
        ];
    }

    /**
     * @param \App\Model\Entity\Payment                             $payment
     * @param \net\authorize\api\contract\v1\TransactionRequestType $transactionRequestType
     * @return void
     */
    protected function __setPaymentOrProfile(&$payment, AnetAPI\TransactionRequestType &$transactionRequestType): void {

        if (empty($payment->payment_profile_id)) {
            $authPayment = $this->__getAuthPayment($payment);
            $transactionRequestType->setPayment($authPayment);
        } else {
            $paymentProfileTable = TableRegistry::getTableLocator()->get('Scid.PaymentProfiles');
            if (empty($payment->payment_profile)) {
                $payment->payment_profile = $paymentProfileTable->get($payment->payment_profile_id, ['contain' => ['CustomerProfiles']]);
            }
            if (empty($payment->payment_profile->customer_profile)) {
                $payment->payment_profile->customer_profile = $paymentProfileTable->CustomerProfiles->get($payment->payment_profile->customer_profile_id);
            }
            if (empty($payment->payment_profile->card_number)) {
                $payment->payment_profile->updateFromRemote();
            }
            if (!empty($payment->payment_profile->address)) {
                $payment->address = $payment->payment_profile->address;
            }
            if (!empty($payment->payment_profile->city)) {
                $payment->city = $payment->payment_profile->city;
            }
            if (!empty($payment->payment_profile->state)) {
                $payment->state = $payment->payment_profile->state;
            }
            if (!empty($payment->payment_profile->zip)) {
                $payment->zip = $payment->payment_profile->zip;
            }
            if (!empty($payment->payment_profile->customer_profile->email)) {
                $payment->email = $payment->payment_profile->customer_profile->email;
            }
            $payment->last = $payment->payment_profile->last;
            $payment->first = $payment->payment_profile->first;
            $payment->number = $payment->payment_profile->number;
            $payment->expDate = $payment->payment_profile->expiration->format('m/Y');
            $payment->paymentType = $payment->payment_profile->card_type;
            $profileToCharge = new AnetAPI\CustomerProfilePaymentType();
            $profileToCharge->setCustomerProfileId($payment->payment_profile->customer_profile->profile_id);
            $paymentProfile = new AnetAPI\PaymentProfileType();
            $paymentProfile->setPaymentProfileId($payment->payment_profile->payment_profile_id);
            $profileToCharge->setPaymentProfile($paymentProfile);
            $transactionRequestType->setProfile($profileToCharge);
        }
    }
}
