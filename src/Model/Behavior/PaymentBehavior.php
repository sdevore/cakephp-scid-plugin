<?php

namespace Scid\Model\Behavior;

use App\Model\Entity\Payment;
use App\Model\Table\PaymentsTable;
use Cake\Log\Log;
use Cake\ORM\Locator\TableLocator;
use Cake\ORM\TableRegistry;
use Money\Number;
use Scid\Model\Entity\MoneyEntityTrait;
use ArrayObject;
use Cake\Core\Configure;
use Cake\Datasource\EntityInterface;
use Cake\Event\Event;
use Cake\ORM\Behavior;
use Cake\ORM\Table;
use Money\Currencies\ISOCurrencies;
use Money\Currency;
use Money\Formatter\DecimalMoneyFormatter;
use Money\Money;
use Money\Parser\IntlMoneyParser;
use net\authorize\api\contract\v1 as AnetAPI;
use net\authorize\api\controller as AnetController;
use PhpParser\Node\Expr\Empty_;
use Scid\Utility\ScidPaymentsInterface;
use Scid\Utility\ScidPaymentsTrait;
use Tools\Model\Entity\Entity;
use Tools\Utility\Text;

/**
 * Payment behavior
 */
class PaymentBehavior extends Behavior implements ScidPaymentsInterface
{

    use MoneyEntityTrait;
    use ScidPaymentsTrait;

    /**
     * Default configuration.
     *
     * @var array
     */


    public function initialize(array $config) {
        parent::initialize($config); // TODO: Change the autogenerated stub
        $this->_initialize($config);


    }

    /**
     * @param Event           $event
     * @param EntityInterface $payment
     * @param ArrayObject     $options
     * @return void|boolean
     */
    public function beforeSave(Event $event, EntityInterface $payment, ArrayObject $options) {
        if (!empty($options[self::TRANSACTION_TRANSACTION_KEY_KEY])) {
            $this->_options['transaction_key'] = $options[self::TRANSACTION_TRANSACTION_KEY_KEY];
        }
        if (!empty($options[self::TRANSACTION_ID_PREFIX_KEY])) {
            $this->_options[self::TRANSACTION_ID_PREFIX_KEY] = $options[self::TRANSACTION_ID_PREFIX_KEY];
        }
        if (!empty($options[self::TRANSACTION_TYPE_KEY])) {
            switch ($options[self::TRANSACTION_TYPE_KEY]) {
                case self::TRANSACTION_TYPE_AUTHORIZE:
                    if (!$this->authorize($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_CAPTURE:
                    if (!$this->capture($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_AUTH_CAPTURE:
                    if (!$this->charge($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_VOID:
                    if (!$this->void($payment)) {
                        $event->stopPropagation();
                        return FALSE;
                    }
                    break;
                case self::TRANSACTION_TYPE_REFUND:
                    $payment->setError('type', [__('Refund not supported at this time')]);
                    $event->stopPropagation();
                    return;
                    break;
            }
            if (!empty($payment->save_payment_information) && $payment->save_payment_information) {
                if (!empty($options[self::TRANSACTION_TYPE_KEY])) {
                    switch ($options[self::TRANSACTION_TYPE_KEY]) {
                        case self::TRANSACTION_TYPE_CAPTURE:
                        case self::TRANSACTION_TYPE_AUTH_CAPTURE:
                            $test = $this->saveCustomerAndPayment($payment);
                            if (!empty($test->getError('save_payment_information'))) {
                                $payment->set('save_payment_information_error', $test->getError('save_payment_information'));
                            }

                    }
                }
            }
        }
    }


    /**
     * @param \App\Model\Entity\Payment $payment
     * @return bool|\App\Model\Entity\Payment
     */
    function createCustomerProfileFromTransaction($payment) {
        /* Create a merchantAuthenticationType object with authentication details
           retrieved from the constants file */
        $merchantAuthentication = $this->__getMerchantAuthentication();
        // Set the transaction's refId
        $refId = 'ref' . time();

        $customerProfile = new AnetAPI\CustomerProfileBaseType();
        $customerProfile->setMerchantCustomerId($payment->member_id);
        $customerProfile->setEmail($payment->member->email);
        $customerProfile->setDescription($payment->member->name);

        $request = new AnetAPI\CreateCustomerProfileFromTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $request->setTransId($payment->transactionNumber);

        // You can either specify the customer information in form of customerProfileBaseType object
        if (empty($payment->member->customer_profiles)) {
            $request->setCustomer($customerProfile);
        } else {
            // find one that matches type
            $found = FALSE;
            foreach ($payment->member->customer_profiles as $customer_profile) {
                if ($customer_profile->config == $this->_credentials) {
                    $request->setCustomerProfileId($customer_profile->profile_id);
                    $found = TRUE;
                }
            }
            if (!$found) {
                $request->setCustomer($customerProfile);
            }
        }
        //  OR
        // You can just provide the customer Profile ID
        //$request->setCustomerProfileId("123343");

        $controller = new AnetController\CreateCustomerProfileFromTransactionController($request);

        /** @var \net\authorize\api\contract\v1\CreateCustomerProfileResponse $response */
        $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);

        if (($response != NULL) && ($response->getMessages()->getResultCode() == "Ok")) {
            /** @var \Scid\Model\Table\CustomerProfilesTable $customerProfiles */
            $profile_id = $response->getCustomerProfileId();
            $customerProfiles = TableRegistry::getTableLocator()->get('Scid.CustomerProfiles');
            $profile = $customerProfiles->newEntity(
                ['member_id'  => $payment->member->id,
                 'profile_id' => $profile_id,
                 'config'     => $this->_credentials,
                 'email'      => $payment->member->email,
                ]);
            if (!empty($response->getCustomerPaymentProfileIdList())) {
                $payment_profile_id_list = $response->getCustomerPaymentProfileIdList();
                $id = array_shift($payment_profile_id_list);
                $payment = $customerProfiles->PaymentProfiles->newEntity([
                                                                             'member_id'           => $payment->member->id,
                                                                             'customer_profile_id' => $profile_id,
                                                                             'payment_profile_id'  => $id,
                                                                             'card_number'         => $payment->credit_card_number,
                                                                             'expiration_date'     => $payment->expDate,
                                                                             'is_default'          => TRUE,
                                                                         ]);
                $profile->payment_profiles = [$payment];
            }
            if ($customerProfiles->save($profile)) {
                $payment->set('customer_profiles', [$profile]);
            } else {
                $payment->setError('save_payment_information', $payment->getErrors());
            }
        } else {

            $errorMessages = $response->getMessages()->getMessage();

            $payment->setError('save_payment_information', $errorMessages[0]->getCode() . "  " . $errorMessages[0]->getText());
        }
        return $payment;
    }

    /**
     * @param EntityInterface|\App\Model\Entity\Payment $payment
     *
     * @return bool|\App\Model\Entity\Payment
     */
    public
    function saveCustomerAndPayment($payment) {

        if (!empty($payment->transactionNumber)) {
            return $this->createCustomerProfileFromTransaction($payment);
        } else {

        }
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $authPayment = $this->__getAuthPayment($payment);
        $order = $this->__getOrder($payment);

        $customerData = $this->__getCustomerData($payment);
        $customerAddress = $this->__getCustomerAddress($payment);


        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);
        $amount = $this->cleanMoney($payment->amountPaid);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        $transactionRequestType->setPayment($authPayment);
        $transactionRequestType->setCustomer($customerData);
        $transactionRequestType->setBillTo($customerAddress);
        $transactionRequestType->addToTransactionSettings($this->__duplicateWindowSetting());
        $transactionRequestType->addToTransactionSettings($this->__emailCustomerSetting(FALSE));
        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);

        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $tresponse */
                    $tresponse = $response->getTransactionResponse();

                    if ($tresponse != NULL && $tresponse->getMessages() != NULL) {
                        $payment->transactionNumber = $tresponse->getTransId();
                        $payment->authorizationNumber = $tresponse->getAuthCode();
                        $payment->scid_state = self::STATE_APPROVED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $tresponse->getTransId();
                        $result['response_code'] = $tresponse->getResponseCode();
                        $result['code'] = $tresponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $tresponse->getAuthCode();
                        $result['description'] = $tresponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($tresponse->getErrors() != NULL) {
                            $errorCode = $tresponse->getErrors()[0]->getErrorCode();
                            $errorText = $tresponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $payment->setError('credit_card_number', [__('{0}: {1}',
                                                                         [$errorCode,
                                                                          $errorText])]);
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $tresponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($tresponse != NULL && $tresponse->getErrors() != NULL) {
                        $errorCode = $tresponse->getErrors()[0]->getErrorCode();

                        $errorText = $tresponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No response received');
                $payment->setError('credit_card_number', [__('No reponse received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }
        return $payment;

    }

    public
    function updateCustomerPaymentInformation($paymentInfo) {
        return NULL;
    }

    /**
     * @param Payment|EntityInterface $payment
     * @return Payment|boolean
     */
    public
    function authorize($payment) {
        $transactionType = self::TRANSACTION_TYPE_AUTHORIZE;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $authPayment = $this->__getAuthPayment($payment);
        $order = $this->__getOrder($payment);

        $customerData = $this->__getCustomerData($payment);
        $customerAddress = $this->__getCustomerAddress($payment);


        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);
        $amount = $this->cleanMoney($payment->amountPaid);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        $transactionRequestType->setPayment($authPayment);
        $transactionRequestType->setCustomer($customerData);
        $transactionRequestType->setBillTo($customerAddress);
        $transactionRequestType->addToTransactionSettings($this->__duplicateWindowSetting());
        $transactionRequestType->addToTransactionSettings($this->__emailCustomerSetting(FALSE));
        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);

        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $tresponse */
                    $tresponse = $response->getTransactionResponse();

                    if ($tresponse != NULL && $tresponse->getMessages() != NULL) {
                        $payment->transactionNumber = $tresponse->getTransId();
                        $payment->authorizationNumber = $tresponse->getAuthCode();
                        $payment->scid_state = self::STATE_APPROVED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $tresponse->getTransId();
                        $result['response_code'] = $tresponse->getResponseCode();
                        $result['code'] = $tresponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $tresponse->getAuthCode();
                        $result['description'] = $tresponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($tresponse->getErrors() != NULL) {
                            $errorCode = $tresponse->getErrors()[0]->getErrorCode();
                            $errorText = $tresponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $payment->setError('credit_card_number', [__('{0}: {1}',
                                                                         [$errorCode,
                                                                          $errorText])]);
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $tresponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($tresponse != NULL && $tresponse->getErrors() != NULL) {
                        $errorCode = $tresponse->getErrors()[0]->getErrorCode();

                        $errorText = $tresponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No response received');
                $payment->setError('credit_card_number', [__('No reponse received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }
        return $payment;

    }


    /**
     * @param EntityInterface|Payment $payment
     * @param array                   $options
     * @return Payment|boolean
     */
    public
    function capture($payment, $options = []) {
        $transactionType = self::TRANSACTION_TYPE_CAPTURE;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $authPayment = $this->__getAuthPayment($payment);
        $order = $this->__getOrder($payment);


        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);
        $amount = $this->cleanMoney($payment->amountPaid);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        if (!empty($payment->transactionNumber)) {
            $transactionRequestType->setRefTransId($payment->transactionNumber);
        } else {
            $payment->setError('transactionNumber', [__('Transaction for capture is not set')]);
            $payment->scid_state = self::STATE_FAILED;
        }
        $customerData = $this->__getCustomerData($payment);
        $transactionRequestType->setCustomer($customerData);
        $transactionRequestType->addToTransactionSettings($this->__duplicateWindowSetting());
        $transactionRequestType->addToTransactionSettings($this->__emailCustomerSetting(TRUE));

        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $tresponse */
                    $tresponse = $response->getTransactionResponse();

                    if ($tresponse != NULL && $tresponse->getMessages() != NULL) {
                        $payment->transactionNumber = $tresponse->getTransId();
                        $payment->authorizationNumber = $tresponse->getAuthCode();
                        $payment->scid_state = self::STATE_CAPTURED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $tresponse->getTransId();
                        $result['response_code'] = $tresponse->getResponseCode();
                        $result['code'] = $tresponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $tresponse->getAuthCode();
                        $result['description'] = $tresponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($tresponse->getErrors() != NULL) {
                            $errorCode = $tresponse->getErrors()[0]->getErrorCode();
                            $errorText = $tresponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $this->__setError($payment, $errorCode, $errorText);
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $tresponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($tresponse != NULL && $tresponse->getErrors() != NULL) {
                        $errorCode = $tresponse->getErrors()[0]->getErrorCode();

                        $errorText = $tresponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No reponse received');
                $payment->setError('credit_card_number', [__('No reponse received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }

        return $payment;
    }

    /**
     * @param EntityInterface|Payment $payment
     *
     * @return Payment|boolean
     */
    public
    function charge($payment) {
        $transactionType = self::TRANSACTION_TYPE_AUTH_CAPTURE;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $authPayment = $this->__getAuthPayment($payment);
        $order = $this->__getOrder($payment);

        $customerData = $this->__getCustomerData($payment);
        $customerAddress = $this->__getCustomerAddress($payment);

        // Add values for transaction settings
        $duplicateWindowSetting = $this->__duplicateWindowSetting();

        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);
        $amount = $this->cleanMoney($payment->amountPaid);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        $transactionRequestType->setPayment($authPayment);
        $transactionRequestType->setCustomer($customerData);
        $transactionRequestType->setBillTo($customerAddress);
        $transactionRequestType->addToTransactionSettings($duplicateWindowSetting);

        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $tresponse */
                    $tresponse = $response->getTransactionResponse();

                    if ($tresponse != NULL && $tresponse->getMessages() != NULL) {
                        $payment->transactionNumber = $tresponse->getTransId();
                        $payment->authorizationNumber = $tresponse->getAuthCode();
                        $payment->scid_state = self::STATE_CAPTURED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $tresponse->getTransId();
                        $result['response_code'] = $tresponse->getResponseCode();
                        $result['code'] = $tresponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $tresponse->getAuthCode();
                        $result['description'] = $tresponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($tresponse->getErrors() != NULL) {
                            $errorCode = $tresponse->getErrors()[0]->getErrorCode();
                            $errorText = $tresponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $this->__setError($payment, $errorCode, $errorText);
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $tresponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($tresponse != NULL && $tresponse->getErrors() != NULL) {
                        $errorCode = $tresponse->getErrors()[0]->getErrorCode();

                        $errorText = $tresponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No reponse received');
                $payment->setError('credit_card_number', [__('No reponse received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }
        return $payment;
    }

    /**
     * @param Payment|EntityInterface $payment
     *
     * @return bool
     */
    public
    function void($payment) {
        $transactionType = self::TRANSACTION_TYPE_VOID;
        $merchantAuthentication = $this->__getMerchantAuthentication();
        if ($payment->scid_state != self::STATE_APPROVED) {
            $payment->setError('state', [__('Only payments that are approved can be voided')]);
        }

        // Add values for transaction settings
        $duplicateWindowSetting = $this->__duplicateWindowSetting();

        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();

        $transactionRequestType->setTransactionType($transactionType);

        $transactionRequestType->addToTransactionSettings($duplicateWindowSetting);
        if (!empty($payment->transactionNumber)) {
            $transactionRequestType->setRefTransId($payment->transactionNumber);
        } else {
            $payment->setError('transactionNumber', [__('Transaction for capture is not set')]);
            $payment->scid_state = self::STATE_FAILED;
        }
        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);

        $payment->scid_ref_id = $this->__getReferenceId();
        $request->setRefId($payment->scid_ref_id);
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if (!$payment->getErrors()) {
            if ($this->_sandbox) {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
            } else {
                $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
            }
            $result = [];
            if ($response != NULL) {
                $result['response'] = $response;
                // Check to see if the API request was successfully received and acted upon
                if ($response->getMessages()->getResultCode() == "Ok") {
                    // Since the API request was successful, look for a transaction response
                    // and parse it to display the results of authorizing the card
                    /** @var AnetAPI\TransactionResponseType $tresponse */
                    $tresponse = $response->getTransactionResponse();

                    if ($tresponse != NULL && $tresponse->getMessages() != NULL) {
                        $payment->transactionNumber = $tresponse->getTransId();
                        $payment->authorizationNumber = $tresponse->getAuthCode();
                        $payment->scid_state = self::STATE_VOIDED;
                        $result['failed'] = FALSE;
                        $result['transaction_id'] = $tresponse->getTransId();
                        $result['response_code'] = $tresponse->getResponseCode();
                        $result['code'] = $tresponse->getMessages()[0]->getCode();
                        $result['auth_code'] = $tresponse->getAuthCode();
                        $result['description'] = $tresponse->getMessages()[0]->getDescription();

                    } else {
                        $payment->scid_state = self::STATE_FAILED;

                        $result['failed'] = TRUE;
                        if ($tresponse->getErrors() != NULL) {
                            $errorCode = $tresponse->getErrors()[0]->getErrorCode();
                            $errorText = $tresponse->getErrors()[0]->getErrorText();
                            $result['error_code'] = $errorCode;
                            $result['error_message'] = $errorText;
                            $this->__setError($payment, $errorCode, $errorText);
                        } else {
                            $payment->setError('credit_card_number', ['Transaction failed']);
                        }
                    }
                    // Or, print errors if the API request wasn't successful
                } else {
                    $result['failed'] = TRUE;
                    $tresponse = $response->getTransactionResponse();
                    $payment->scid_state = self::STATE_FAILED;
                    if ($tresponse != NULL && $tresponse->getErrors() != NULL) {
                        $errorCode = $tresponse->getErrors()[0]->getErrorCode();

                        $errorText = $tresponse->getErrors()[0]->getErrorText();
                        $result['error_message'] = $errorText;
                        $result['error_code'] = $errorCode;
                        $this->__setError($payment, $errorCode, $errorText);
                    } else {
                        $errorCode = $response->getMessages()->getMessage()[0]->getCode();
                        $result['error_code'] = $errorCode;
                        $errorText = $response->getMessages()->getMessage()[0]->getText();
                        $result['error_message'] = $errorText;
                        $this->__setError($payment, $errorCode, $errorText);
                    }
                }
            } else {
                $payment->scid_state = self::STATE_FAILED;
                $result['error_message'] = __('No reponse received');
                $payment->setError('credit_card_number', [__('No response received')]);
            }
            $payment->set('response', $result);
        } else {
            $payment->scid_state = self::STATE_FAILED;
        }
        if ($payment->scid_state == self::STATE_FAILED) {
            return FALSE;
        }
        return $payment;
    }


    /**
     * @param \App\Model\Entity\Payment      $payment
     * @param array                          $data
     * @param \App\Model\Entity\Member|array $member
     *
     * @return array
     */
    public
    function charge2($data, $member) {
        $merchantAuthentication = $this->__getMerchantAuthentication();
        $this->__getReferenceId();

        // create the credit card
        $opaqueData = new AnetAPI\OpaqueDataType();
        $opaqueData->setDataDescriptor($data['dataDescriptor']);
        $opaqueData->setDataValue($data['dataValue']);

        $paymentOne = new AnetAPI\PaymentType();
        $paymentOne->setOpaqueData($opaqueData);

        $order = new AnetAPI\OrderType();
        if (!empty($data['invoice_number'])) {
            $order->setInvoiceNumber($data['invoice_number']);
        }
        if (!empty($data['payment_description'])) {
            $order->setDescription($data['payment_description']);
        } else {
            $order->setDescription(__('CFSD 16 Community Schools Payment'));
        }
        // Set the customer's identifying information
        $customerData = new AnetAPI\CustomerDataType();
        $customerData->setType("individual");
        if ($member instanceof Entity) {
            $customerData->setId($member->id);
            $customerData->setEmail($member->email);
        } else if (is_array($member) && !empty($member['id'])) {
            $customerData->setId($member['id']);
            $customerData->setEmail($member['email']);

        }


        if (!empty($data['items'])) {
            $items = [];
            foreach ($data['items'] as $index => $item) {
                if ($index < 25) {
                    $lineItem = new AnetAPI\LineItemType();
                    if (!empty($item['description'])) {
                        $lineItem->setDescription(Text::truncate($item['description'], 200));
                    }
                    $lineItem->setItemId($item['id']);
                    $lineItem->setName(Text::truncate($item['name'], 25));
                    $unitPrice = $this->cleanMoney($item['fee']);
                    $lineItem->setQuantity(1);
                    $lineItem->setUnitPrice($unitPrice);
                    $items[] = $lineItem;
                } else {

                    break;
                }
            }

        }
        $duplicateWindowSetting = $this->__duplicateWindowSetting();

        // Create a TransactionRequestType object and add the previous objects to it
        $transactionRequestType = new AnetAPI\TransactionRequestType();
        $transactionRequestType->setTransactionType(self::TRANSACTION_TYPE_AUTHORIZE);
        $amount = $this->cleanMoney($data['amountPaid']);
        $transactionRequestType->setAmount($amount);
        $transactionRequestType->setOrder($order);
        $transactionRequestType->setPayment($paymentOne);
        $transactionRequestType->setCustomer($customerData);
        $transactionRequestType->addToTransactionSettings($duplicateWindowSetting);
//            if (!empty($items)) {
//                $transactionRequestType->setLineItems($items);
//            }

        // Assemble the complete transaction request
        $request = new AnetAPI\CreateTransactionRequest();
        $request->setMerchantAuthentication($merchantAuthentication);
        $request->setRefId($this->__getReferenceId());
        $request->setTransactionRequest($transactionRequestType);
        // Create the controller and get the response
        $controller = new AnetController\CreateTransactionController($request);
        if ($this->_sandbox) {
            $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::SANDBOX);
        } else {
            $response = $controller->executeWithApiResponse(\net\authorize\api\constants\ANetEnvironment::PRODUCTION);
        }
        $result = [];
        if ($response != NULL) {
            $result['response'] = $response;
            // Check to see if the API request was successfully received and acted upon
            if ($response->getMessages()->getResultCode() == "Ok") {
                // Since the API request was successful, look for a transaction response
                // and parse it to display the results of authorizing the card
                $tresponse = $response->getTransactionResponse();

                if ($tresponse != NULL && $tresponse->getMessages() != NULL) {
                    $result['failed'] = FALSE;
                    $result['transaction_id'] = $tresponse->getTransId();
                    $result['response_code'] = $tresponse->getResponseCode();
                    $result['code'] = $tresponse->getMessages()[0]->getCode();
                    $result['auth_code'] = $tresponse->getAuthCode();
                    $result['description'] = $tresponse->getMessages()[0]->getDescription();
                } else {
                    $result['failed'] = TRUE;
                    if ($tresponse->getErrors() != NULL) {
                        $result['error_code'] = $tresponse->getErrors()[0]->getErrorCode();
                        $result['error_message'] = $tresponse->getErrors()[0]->getErrorText();
                    }
                }
                // Or, print errors if the API request wasn't successful
            } else {
                $result['failed'] = TRUE;
                $tresponse = $response->getTransactionResponse();

                if ($tresponse != NULL && $tresponse->getErrors() != NULL) {
                    $result['error_code'] = $tresponse->getErrors()[0]->getErrorCode();
                    $result['error_message'] = $tresponse->getErrors()[0]->getErrorText();
                } else {
                    $result['error_code'] = $response->getMessages()->getMessage()[0]->getCode();
                    $result['error_message'] = $response->getMessages()->getMessage()[0]->getText();
                }
            }
        } else {
            $result['error_message'] = __('No response received');
        }
        return $result;
    }


    /**
     * @return string
     */
    protected
    function __getReferenceId() {
        return 'ref' . time();
    }

    /**
     * @return AnetAPI\SettingType
     */
    protected
    function __duplicateWindowSetting(): AnetAPI\SettingType {
// Add values for transaction settings
        $duplicateWindowSetting = new AnetAPI\SettingType();
        $duplicateWindowSetting->setSettingName("duplicateWindow");
        $duplicateWindowSetting->setSettingValue("60");
        return $duplicateWindowSetting;
    }

    protected
    function __emailCustomerSetting($value = FALSE): AnetAPI\SettingType {
        $setting = new AnetAPI\SettingType();
        $setting->setSettingName("emailCustomer");
        $setting->setSettingValue($value);
        return $setting;
    }

    /**
     * @param $payment
     *
     * @return AnetAPI\CustomerDataType
     */
    protected
    function __getCustomerData($payment): AnetAPI\CustomerDataType {
        $customerData = new AnetAPI\CustomerDataType();
        $customerData->setType("individual");
        if (!empty($payment->email)) {
            $customerData->setEmail($payment->email);
        } else if (!empty($payment->member->email)) {
            $customerData->setEmail($payment->member->email);
        } else {
            $payment->setError('email', [__('no email was set')]);
        }
        if (!empty($payment->member_id)) {
            $customerData->setId($payment->member_id);
        }
        return $customerData;
    }

    /**
     * @param $payment
     *
     * @return AnetAPI\CustomerAddressType
     */
    protected
    function __getCustomerAddress($payment): AnetAPI\CustomerAddressType {
        $customerAddress = new AnetAPI\CustomerAddressType();
        $customerAddress->setFirstName($payment->first);
        $customerAddress->setLastName($payment->last);
        if (!empty($payment->zip)) {
            $customerAddress->setZip($payment->zip);
        }
        if (!empty($payment->address)) {
            $customerAddress->setAddress($payment->address);
        }
        if (!empty($payment->city)) {
            $customerAddress->setCity($payment->city);
        }
        if (!empty($payment->state)) {
            $customerAddress->setState($payment->state);
        }

        return $customerAddress;
    }

    /**
     * @param $payment
     *
     * @return array
     */
    protected
    function __getPaymentItems($payment): array {
        $items = [];
        if (!empty($payment->items)) {
            foreach ($payment->items as $index => $item) {
                if ($index < 25) {
                    $lineItem = new AnetAPI\LineItemType();
                    if (!empty($item['description'])) {
                        $lineItem->setDescription(Text::truncate($item['description'], 200));
                    }
                    $lineItem->setItemId($item['id']);
                    $lineItem->setName(Text::truncate($item['name'], 25));
                    $unitPrice = $this->cleanMoney($item['fee']);
                    $lineItem->setQuantity(1);
                    $lineItem->setUnitPrice($unitPrice);
                    $items[] = $lineItem;
                } else {
                    $lineItem = new AnetAPI\LineItemType();
                    $lineItem->setItemId(0);
                    $lineItem->setName(__('Limit of items.'));
                    $unitPrice = $this->cleanMoney(0);
                    $lineItem->setQuantity(1);
                    $lineItem->setUnitPrice($unitPrice);
                    $items[] = $lineItem;
                    break;
                }
            }

        }
        return $items;
    }


    /**
     * @param $payment
     *
     * @return AnetAPI\PaymentType
     */
    protected
    function __getAuthPayment($payment): AnetAPI\PaymentType {
        $paymentOne = new AnetAPI\PaymentType();
        // create the credit card
        $validatePayment = FALSE;

        if ($payment->has('dataDescriptor') && $payment->has('dataValue')) {
            // use nonce / opaqueData
            $opaqueData = new AnetAPI\OpaqueDataType();
            $opaqueData->setDataDescriptor($payment->dataDescriptor);
            $opaqueData->setDataValue($payment->dataValue);
            $paymentOne->setOpaqueData($opaqueData);
            $validatePayment = TRUE;
        } else {
            $card = new AnetAPI\CreditCardType();
            if (!empty($payment->credit_card_number)) {
                $number = preg_replace('/\D+/', '', $payment->credit_card_number);
                $card->setCardNumber($number);
                $payment->number = substr($number, -4);
            } else {
                $payment->setError('credit_card_number', [__('credit card number is required')]);
            }
            if (!empty($payment->card_code)) {
                $card->setCardCode($payment->card_code);
            } else {
                $payment->setError('card_code', [__('credit card verification number is required')]);
            }
            if (!empty($payment->expiration_date)) {
                $month = $payment->expiration_date->month;
                $year = $payment->expiration_date->year;
                //Log::debug( $year, 'payment_debug');
                //Log::debug( $month, 'payment_debug');
                $card->setExpirationDate($payment->expiration_date->format('Y-m'));
            } else {
                $payment->setError('expiration_date', [__('no valid expiration date was set')]);
            }
            $paymentOne->setCreditCard($card);
        }
        return $paymentOne;
    }

    /**
     * @param Payment $payment
     * @param integer $errorCode
     * @param string  $errorText
     * @return void
     */
    protected
    function __setError($payment, $errorCode, $errorText): void {
        $errorText = [$errorText];
        switch ($errorCode) {
            case 5:
                $payment->setError('amountPaid', $errorText);
                break;
            case 6:
                $payment->setError('credit_card_number', $errorText);
                break;
            case 7:
            case 8:
                $payment->setError('expMonth', $errorText);
                $payment->setError('expYear', $errorText);
                break;
            case 9:
                $payment->setError('routing_number', $errorText);
                break;
            case 10:
                $payment->setError('account_number', $errorText);
                break;
            case 11:
                $payment->setError('credit_card_number', $errorText);
                break;
            case 12:
                $payment->setError('card_code', $errorText);
                break;
            default:
                $payment->setError('credit_card_number', [__('{0}: {1}',
                                                             [$errorCode,
                                                              $errorText[0]])]);
        }
    }

    /**
     * @param $payment
     *
     * @return AnetAPI\OrderType
     */
    protected
    function __getOrder($payment): AnetAPI\OrderType {
        $order = new AnetAPI\OrderType();
        if (!empty($payment->registrationID)) {
            $invoiceNumber = $payment->registrationID;
            if (!empty($this->_options[self::TRANSACTION_ID_PREFIX_KEY])) {
                $invoiceNumber = $this->_options[self::TRANSACTION_ID_PREFIX_KEY] . '-' . $invoiceNumber;
            }
            $order->setInvoiceNumber($invoiceNumber);
        }
        if (!empty($payment->note)) {
            $order->setDescription(Text::truncate($payment->note, 230));
        } else {
            $order->setDescription(__('CFSD 16 Community Schools Payment'));
        }
        return $order;
    }

    public
    function paymentStatuses() {
        return [
            'Pending'  => 'Pending',
            'Approved' => 'Approved',
            'Failed'   => 'Failed',
            'Captured' => 'Captured',
            'Settled'  => 'Settled',
            'Voided'   => 'Refunded',
        ];
    }

}
